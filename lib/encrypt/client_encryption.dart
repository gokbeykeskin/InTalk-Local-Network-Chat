import 'dart:io';
import 'dart:math';

import 'package:encrypt/encrypt.dart';

import 'encryption.dart';

class ClientSideEncryption extends BaseEncryption {
  //The private key of the client (Diffie-Hellman key exchange)
  final BigInt _secretNumber;
  //This is the secret key that is used to encrypt and decrypt messages
  //(created late using the intermediate key generated by the server)
  late Key _secretKey;
  //This is the initialization vector that is used to encrypt and decrypt messages
  late IV _iv;
  //This is the encrypter that is used to encrypt and decrypt messages
  Encrypter? _encrypter;

  ClientSideEncryption()
      : _secretNumber = BigInt.from(Random().nextInt(4294967296));
  //This is created by the client and sent to client on login.
  BigInt generateIntermediateKey() {
    return g.modPow(_secretNumber, n);
  }

  //This is created by the client by using the intermediate key sent by the server
  void generateFinalKey(BigInt serversIntermediateKey, String iv) {
    BigInt intKey = serversIntermediateKey.modPow(_secretNumber, n);
    if (intKey.toString().length > 32) {
      intKey = BigInt.parse(intKey.toString().substring(0, 32));
    } else if (intKey.toString().length < 32) {
      //this is for handling the extreme error case where the final key is less than 32 characters long
      //both the server and client does this so even if the server sends a key that is less than 32 characters long
      //they both will pad it to 32 characters
      intKey = BigInt.parse(intKey.toString().padRight(32, '0'));
    }
    _secretKey = Key.fromUtf8(intKey.toString());
    _iv = IV.fromBase64(iv);
    _encrypter = Encrypter(AES(_secretKey, padding: null));
  }

  @override
  Future<String> encrypt(Socket? socket, String plainText) async {
    while (_encrypter == null) {
      await Future.delayed(const Duration(milliseconds: 100));
    }
    final encrypted = _encrypter?.encrypt(plainText, iv: _iv);

    return Future.value(encrypted!.base64);
  }

  @override
  Future<String> decrypt(Socket? socket, String cipherText) async {
    while (_encrypter == null) {
      await Future.delayed(const Duration(milliseconds: 100));
    }
    final encrypted = Encrypted.fromBase64(cipherText);
    final decrypted = _encrypter!.decrypt(encrypted, iv: _iv);
    return Future.value(decrypted);
  }
}
