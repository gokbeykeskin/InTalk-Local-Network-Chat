import 'dart:io';
import 'dart:math';

import 'package:encrypt/encrypt.dart';

import 'encryption.dart';

class ClientSideEncryption extends BaseEncryption {
  //These are the values of g and n that are used in the Diffie-Hellman key exchange
  //They are public and can be used by anyone
  final BigInt _g = BigInt.parse('61002891148799367012041784081793');
  final BigInt _n = BigInt.parse('71015449566417566598295305556981');
  //The private key of the client (Diffie-Hellman key exchange)
  BigInt myNumber;
  //This is the secret key that is used to encrypt and decrypt messages
  //(created late using the intermediate key generated by the server)
  late Key secretKey;
  //This is the initialization vector that is used to encrypt and decrypt messages
  late IV iv;
  //This is the encrypter that is used to encrypt and decrypt messages
  Encrypter? encrypter;

  ClientSideEncryption() : myNumber = BigInt.from(Random().nextInt(4294967296));
  //This is created by the client and sent to client on heartbeat.
  BigInt generateIntermediateKey() {
    return _g.modPow(myNumber, _n);
  }

  //This is created by the client by using the intermediate key sent by the server
  void generateFinalKey(BigInt serversIntermediateKey, String iv) {
    BigInt intKey = serversIntermediateKey.modPow(myNumber, _n);
    if (intKey.toString().length > 32) {
      intKey = BigInt.parse(intKey.toString().substring(0, 32));
    } else if (intKey.toString().length < 32) {
      //this is for handling the extreme error case where the final key is less than 32 characters long
      //both the server and client does this so even if the server sends a key that is less than 32 characters long
      //they both will pad it to 32 characters
      intKey = BigInt.parse(intKey.toString().padRight(32, '0'));
    }
    secretKey = Key.fromUtf8(intKey.toString());
    this.iv = IV.fromBase64(iv);
    encrypter = Encrypter(AES(secretKey, padding: null));
  }

  @override
  String encrypt(Socket? socket, String plainText) {
    final encrypted = encrypter?.encrypt(plainText, iv: iv);

    return encrypted!.base64;
  }

  @override
  String decrypt(Socket? socket, String cipherText) {
    final encrypted = Encrypted.fromBase64(cipherText);
    final decrypted = encrypter!.decrypt(encrypted, iv: iv);
    return decrypted;
  }
}
